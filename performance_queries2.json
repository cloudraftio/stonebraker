[
    {
      "name": "Database Size",
      "description": "Retrieves database names and their sizes in a human-readable format.",
      "query": "SELECT pg_database.datname AS Database_Name, pg_size_pretty(pg_database_size(pg_database.datname)) AS Database_Size FROM pg_database;",
      "args": [],
      "context": "Useful for monitoring database growth and disk usage."
    },
    {
      "name": "Oldest Transaction ID",
      "description": "Finds the oldest transaction ID to monitor wraparound risk.",
      "query": "SELECT max(age(datfrozenxid)) AS oldest_xid FROM pg_database;",
      "args": [],
      "context": "Critical for vacuum maintenance and preventing transaction ID wraparound."
    },
    {
      "name": "Transaction Wraparound Risk",
      "description": "Calculates the percentage towards transaction ID wraparound and emergency autovacuum.",
      "query": "WITH max_age AS (SELECT 2^31-3000000 AS max_old_xid, setting AS autovacuum_freeze_max_age FROM pg_catalog.pg_settings WHERE name = 'autovacuum_freeze_max_age'), per_database_stats AS (SELECT datname, m.max_old_xid::int, m.autovacuum_freeze_max_age::int, age(d.datfrozenxid) AS oldest_current_xid FROM pg_catalog.pg_database d JOIN max_age m ON (true) WHERE d.datallowconn) SELECT max(oldest_current_xid) AS oldest_current_xid, max(ROUND(100*(oldest_current_xid/max_old_xid::float))) AS percent_towards_wraparound, max(ROUND(100*(oldest_current_xid/autovacuum_freeze_max_age::float))) AS percent_towards_emergency_autovac FROM per_database_stats;",
      "args": [],
      "context": "Monitor transaction ID wraparound risk and autovacuum thresholds."
    },
    {
      "name": "Active Autovacuum Processes",
      "description": "Lists active autovacuum processes with their duration and waiting status.",
      "query": "SELECT datname, usename, state, query, now() - pg_stat_activity.query_start AS duration, wait_event FROM pg_stat_activity WHERE query ~ '^autovacuum:' ORDER BY 5;",
      "args": [],
      "context": "Identify long-running autovacuum processes."
    },
    {
      "name": "Active Vacuum Processes",
      "description": "Lists active VACUUM processes with their duration and waiting status.",
      "query": "SELECT datname, usename, state, query, now() - pg_stat_activity.query_start AS duration, wait_event FROM pg_stat_activity WHERE query ~* '\\A\\s*vacuum\\M' ORDER BY 5;",
      "args": [],
      "context": "Monitor manual or user-initiated VACUUM operations."
    },
    {
      "name": "Vacuum Progress",
      "description": "Shows detailed progress of ongoing VACUUM operations.",
      "query": "SELECT p.pid, now() - a.xact_start AS duration, coalesce(wait_event_type || '.' || wait_event, 'f') AS waiting, CASE WHEN a.query ~ '^autovacuum.*to prevent wraparound' THEN 'wraparound' WHEN a.query ~ '^vacuum' THEN 'user' ELSE 'regular' END AS mode, p.datname AS database, p.relid::regclass AS table, p.phase, a.query, pg_size_pretty(p.heap_blks_total * current_setting('block_size')::int) AS table_size, pg_size_pretty(pg_total_relation_size(p.relid)) AS total_size, pg_size_pretty(p.heap_blks_scanned * current_setting('block_size')::int) AS scanned, pg_size_pretty(p.heap_blks_vacuumed * current_setting('block_size')::int) AS vacuumed, round(100.0 * p.heap_blks_scanned / p.heap_blks_total, 1) AS scanned_pct, round(100.0 * p.heap_blks_vacuumed / p.heap_blks_total, 1) AS vacuumed_pct, p.index_vacuum_count, p.max_dead_tuples AS max_dead_tuples_per_cycle, s.n_dead_tup AS total_num_dead_tuples, ceil(s.n_dead_tup::float / p.max_dead_tuples::float) AS index_cycles_required FROM pg_stat_progress_vacuum p JOIN pg_stat_activity a USING (pid) JOIN pg_stat_all_tables s ON s.relid = p.relid ORDER BY now() - a.xact_start DESC;",
      "args": [],
      "context": "Track the progress of ongoing VACUUM operations."
    },
    {
      "name": "Active Replication Slots",
      "description": "Lists active replication slots with WAL lag information.",
      "query": "SELECT *, age(xmin) AS age_xmin, age(catalog_xmin) AS age_catalog_xmin FROM pg_replication_slots WHERE active = true ORDER BY age(xmin) DESC;",
      "args": [],
      "context": "Check replication health and WAL retention status."
    },
    {
      "name": "Invalid Databases",
      "description": "Counts databases with invalid connection limits.",
      "query": "SELECT count(*) FROM pg_database WHERE datconnlimit = '-2';",
      "args": [],
      "context": "Identify databases with invalid configuration."
    },
    {
      "name": "Orphaned Prepared Transactions",
      "description": "Lists orphaned prepared transactions with their age.",
      "query": "SELECT gid, prepared, owner, database, age(transaction) AS ag_xmin FROM pg_prepared_xacts ORDER BY age(transaction) DESC;",
      "args": [],
      "context": "Identify long-standing prepared transactions that may need cleanup."
    },
    {
      "name": "Autovacuum and Maintenance Parameters",
      "description": "Lists autovacuum and maintenance-related settings.",
      "query": "SELECT name, setting, source, sourcefile FROM pg_settings WHERE name LIKE '%vacuum%' ORDER BY 1; SELECT name, setting, source, sourcefile FROM pg_settings WHERE name = 'maintenance_work_mem';",
      "args": [],
      "context": "Review autovacuum and maintenance configurations."
    },
    {
      "name": "Tables Eligible for Autovacuum",
      "description": "Identifies tables eligible for autovacuum based on thresholds.",
      "query": "WITH vbt AS (SELECT setting AS autovacuum_vacuum_threshold FROM pg_settings WHERE name = 'autovacuum_vacuum_threshold'), vsf AS (SELECT setting AS autovacuum_vacuum_scale_factor FROM pg_settings WHERE name = 'autovacuum_vacuum_scale_factor'), fma AS (SELECT setting AS autovacuum_freeze_max_age FROM pg_settings WHERE name = 'autovacuum_freeze_max_age'), sto AS (SELECT opt_oid, split_part(setting, '=', 1) AS param, split_part(setting, '=', 2) AS value FROM (SELECT oid AS opt_oid, unnest(reloptions) AS setting FROM pg_class) opt) SELECT '\"' || ns.nspname || '\".\"' || c.relname || '\"' AS relation, pg_size_pretty(pg_table_size(c.oid)) AS table_size, age(relfrozenxid) AS xid_age, coalesce(cfma.value::float, autovacuum_freeze_max_age::float) AS autovacuum_freeze_max_age, (coalesce(cvbt.value::float, autovacuum_vacuum_threshold::float) + coalesce(cvsf.value::float, autovacuum_vacuum_scale_factor::float) * c.reltuples) AS autovacuum_vacuum_tuples, n_dead_tup AS dead_tuples FROM pg_class c JOIN pg_namespace ns ON ns.oid = c.relnamespace JOIN pg_stat_all_tables stat ON stat.relid = c.oid JOIN vbt ON (1=1) JOIN vsf ON (1=1) JOIN fma ON (1=1) LEFT JOIN sto cvbt ON cvbt.param = 'autovacuum_vacuum_threshold' AND c.oid = cvbt.opt_oid LEFT JOIN sto cvsf ON cvsf.param = 'autovacuum_vacuum_scale_factor' AND c.oid = cvsf.opt_oid LEFT JOIN sto cfma ON cfma.param = 'autovacuum_freeze_max_age' AND c.oid = cfma.opt_oid WHERE c.relkind = 'r' AND nspname = coalesce(cfma.value::float, autovacuum_freeze_max_age::float) OR coalesce(cvbt.value::float, autovacuum_vacuum_threshold::float) + coalesce(cvsf.value::float, autovacuum_vacuum_scale_factor::float) * c.reltuples > 0 AND datname IS NOT NULL ORDER BY 2 DESC;",
      "args": [],
      "context": "Identify tables needing autovacuum attention."
    },
    {
      "name": "Cache Hit Ratio (Tables)",
      "description": "Calculates cache hit ratio for table reads.",
      "query": "SELECT schemaname, relname AS table_name, round((heap_blks_hit::numeric / (heap_blks_hit + heap_blks_read)::numeric) * 100, 2) AS read_hit_percentage FROM pg_statio_all_tables WHERE heap_blks_hit + heap_blks_read > 0 AND schemaname NOT IN ('pg_catalog', 'information_schema') ORDER BY 3;",
      "args": [],
      "context": "Identify tables with poor cache performance."
    },
    {
      "name": "Cache Hit Ratio (Indexes)",
      "description": "Calculates cache hit ratio for index reads.",
      "query": "SELECT schemaname, relname AS table_name, indexrelname AS index_name, round((idx_blks_hit::numeric / (idx_blks_hit + idx_blks_read)::numeric) * 100, 2) AS read_hit_percentage FROM pg_statio_all_indexes WHERE idx_blks_hit + idx_blks_read > 0 AND schemaname NOT IN ('pg_catalog', 'information_schema') ORDER BY 4;",
      "args": [],
      "context": "Identify indexes with poor cache performance."
    },
    {
      "name": "Top SQL by Total Execution Time",
      "description": "Lists SQL queries with the highest total execution time.",
      "query": "SELECT queryid, substring(query, 1, 60) AS query, calls, round(total_exec_time::numeric, 2) AS total_time_msec, round((total_exec_time::numeric / 1000), 2) AS total_time_sec, round(mean_exec_time::numeric, 2) AS avg_time_msec, round((mean_exec_time::numeric / 1000), 2) AS avg_time_sec, round(stddev_exec_time::numeric, 2) AS standard_deviation_time_msec, round((stddev_exec_time::numeric / 1000), 2) AS standard_deviation_time_sec, round(rows::numeric / calls, 2) AS rows_per_exec, round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 4) AS percent FROM pg_stat_statements ORDER BY total_time_msec DESC LIMIT 20;",
      "args": [],
      "context": "Identify most time-consuming queries for optimization."
    },
    {
      "name": "Top SQL by Average Execution Time",
      "description": "Lists SQL queries with the highest average execution time.",
      "query": "SELECT queryid, substring(query, 1, 60) AS query, calls, round(total_exec_time::numeric, 2) AS total_time_msec, round((total_exec_time::numeric / 1000), 2) AS total_time_sec, round(mean_exec_time::numeric, 2) AS avg_time_msec, round((mean_exec_time::numeric / 1000), 2) AS avg_time_sec, round(stddev_exec_time::numeric, 2) AS standard_deviation_time_msec, round((stddev_exec_time::numeric / 1000), 2) AS standard_deviation_time_sec, round(rows::numeric / calls, 2) AS rows_per_exec, round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 4) AS percent FROM pg_stat_statements ORDER BY avg_time_msec DESC LIMIT 20;",
      "args": [],
      "context": "Identify queries with high average execution times."
    },
    {
      "name": "Top SQL by Percent of Total DB Time",
      "description": "Lists SQL queries consuming the highest percentage of total database time.",
      "query": "SELECT queryid, substring(query, 1, 60) AS query, calls, round(total_exec_time::numeric, 2) AS total_time_msec, round((total_exec_time::numeric / 1000), 2) AS total_time_sec, round(mean_exec_time::numeric, 2) AS avg_time_msec, round((mean_exec_time::numeric / 1000), 2) AS avg_time_sec, round(stddev_exec_time::numeric, 2) AS standard_deviation_time_msec, round((stddev_exec_time::numeric / 1000), 2) AS standard_deviation_time_sec, round(rows::numeric / calls, 2) AS rows_per_exec, round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 4) AS percent FROM pg_stat_statements ORDER BY percent DESC LIMIT 20;",
      "args": [],
      "context": "Identify queries consuming the most database resources."
    },
    {
      "name": "Top SQL by Number of Executions",
      "description": "Lists SQL queries executed the most number of times.",
      "query": "SELECT queryid, substring(query, 1, 60) AS query, calls, round(total_exec_time::numeric, 2) AS total_time_msec, round((total_exec_time::numeric / 1000), 2) AS total_time_sec, round(mean_exec_time::numeric, 2) AS avg_time_msec, round((mean_exec_time::numeric / 1000), 2) AS avg_time_sec, round(stddev_exec_time::numeric, 2) AS standard_deviation_time_msec, round((stddev_exec_time::numeric / 1000), 2) AS standard_deviation_time_sec, round(rows::numeric / calls, 2) AS rows_per_exec, round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 4) AS percent FROM pg_stat_statements ORDER BY calls DESC LIMIT 20;",
      "args": [],
      "context": "Identify frequently executed queries."
    },
    {
      "name": "Top SQL by Shared Blocks Read",
      "description": "Lists SQL queries with the highest shared blocks read (physical reads).",
      "query": "SELECT queryid, substring(query, 1, 60) AS query, calls, round(total_exec_time::numeric, 2) AS total_time_msec, round((total_exec_time::numeric / 1000), 2) AS total_time_sec, round(mean_exec_time::numeric, 2) AS avg_time_msec, round((mean_exec_time::numeric / 1000), 2) AS avg_time_sec, round(stddev_exec_time::numeric, 2) AS standard_deviation_time_msec, round((stddev_exec_time::numeric / 1000), 2) AS standard_deviation_time_sec, round(rows::numeric / calls, 2) AS rows_per_exec, round((100 * total_exec_time / sum(total_exec_time) OVER ())::numeric, 4) AS percent, shared_blks_read FROM pg_stat_statements ORDER BY shared_blks_read DESC LIMIT 20;",
      "args": [],
      "context": "Identify queries causing high physical I/O."
    },
    {
      "name": "List of Users",
      "description": "Lists all users in the database.",
      "query": "SELECT * FROM pg_user;",
      "args": [],
      "context": "Review database users and their privileges."
    },
    {
      "name": "Role Grants",
      "description": "Lists role grants and their options.",
      "query": "SELECT m.rolname AS \"Role name\", r.rolname AS \"Member of\", pg_catalog.concat_ws(', ', CASE WHEN pam.admin_option THEN 'ADMIN' END, CASE WHEN pam.inherit_option THEN 'INHERIT' END, CASE WHEN pam.set_option THEN 'SET' END) AS \"Options\", g.rolname AS \"Grantor\" FROM pg_catalog.pg_roles m JOIN pg_catalog.pg_auth_members pam ON (pam.member = m.oid) LEFT JOIN pg_catalog.pg_roles r ON (pam.roleid = r.oid) LEFT JOIN pg_catalog.pg_roles g ON (pam.grantor = g.oid) WHERE m.rolname !~ '^pg_' ORDER BY 1, 2, 4;",
      "args": [],
      "context": "Review role memberships and permissions."
    },
    {
      "name": "Object Count per Schema",
      "description": "Counts objects in each schema.",
      "query": "SELECT n.nspname AS schema_name, COUNT(*) FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace GROUP BY n.nspname ORDER BY 2 DESC;",
      "args": [],
      "context": "Monitor schema object distribution."
    },
    {
      "name": "Object Count by Type per Schema",
      "description": "Counts objects by type in each schema.",
      "query": "SELECT n.nspname AS schema_name, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 't' THEN 'TOAST table' WHEN 'm' THEN 'materialized view' WHEN 'c' THEN 'composite type' WHEN 'f' THEN 'foreign table' WHEN 'p' THEN 'partitioned table' WHEN 'I' THEN 'partitioned index' END AS object_type, COUNT(1) AS object_count FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind IN ('r', 'v', 'i', 'S', 's') GROUP BY n.nspname, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 't' THEN 'TOAST table' WHEN 'm' THEN 'materialized view' WHEN 'c' THEN 'composite type' WHEN 'f' THEN 'foreign table' WHEN 'p' THEN 'partitioned table' WHEN 'I' THEN 'partitioned index' END ORDER BY n.nspname, CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 't' THEN 'TOAST table' WHEN 'm' THEN 'materialized view' WHEN 'c' THEN 'composite type' WHEN 'f' THEN 'foreign table' WHEN 'p' THEN 'partitioned table' WHEN 'I' THEN 'partitioned index' END;",
      "args": [],
      "context": "Analyze object types within schemas."
    },
    {
      "name": "List of Objects",
      "description": "Lists all objects with their types and owners.",
      "query": "SELECT nsp.nspname AS schema, rol.rolname AS owner, cls.relname AS object_name, CASE cls.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'i' THEN 'index' WHEN 'S' THEN 'sequence' WHEN 't' THEN 'TOAST table' WHEN 'm' THEN 'materialized view' WHEN 'c' THEN 'composite type' WHEN 'f' THEN 'foreign table' WHEN 'p' THEN 'partitioned table' WHEN 'I' THEN 'partitioned index' ELSE cls.relkind::text END AS object_type FROM pg_class cls JOIN pg_roles rol ON rol.oid = cls.relowner JOIN pg_namespace nsp ON nsp.oid = cls.relnamespace ORDER BY 1, 2, 4;",
      "args": [],
      "context": "Review all database objects and their metadata."
    },
    {
      "name": "Tablespace Info",
      "description": "Lists tablespaces with their locations and settings.",
      "query": "SELECT spcname AS Tablespace_Name, pg_catalog.pg_get_userbyid(spcowner) AS Owner, CASE WHEN pg_tablespace_location(oid) = '' AND spcname = 'pg_default' THEN current_setting('data_directory') || '/base/' WHEN pg_tablespace_location(oid) = '' AND spcname = 'pg_global' THEN current_setting('data_directory') || '/global/' ELSE pg_tablespace_location(oid) END AS location, spcacl, spcoptions FROM pg_catalog.pg_tablespace ORDER BY 1;",
      "args": [],
      "context": "Review tablespace configurations."
    },
    {
      "name": "Table Scan Profile",
      "description": "Analyzes table scan patterns (full table scans vs. index scans).",
      "query": "WITH table_size_info AS (SELECT schemaname AS schema_name, relname AS \"Table\", pg_relation_size(relid) AS relation_size, relid, pg_size_pretty(pg_relation_size(relid)) AS \"table_size\", pg_size_pretty(pg_total_relation_size(relid)) AS \"TABLE size + indexes\", pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS \"indexes size\" FROM pg_catalog.pg_statio_all_tables ORDER BY 1, 3 DESC) SELECT b.schema_name, a.relname AS \"Table_Name\", b.table_size AS \"Table_Size\", a.seq_scan AS total_fts_scan, a.seq_tup_read AS total_fts_num_rows_reads, a.seq_tup_read / NULLIF(a.seq_scan, 0) AS fts_rows_per_read, a.idx_scan AS total_idx_scan, a.idx_tup_fetch AS total_Idx_num_rows_read, a.idx_tup_fetch / NULLIF(a.idx_scan, 0) AS idx_rows_per_read, trunc((idx_scan::numeric / NULLIF((idx_scan::numeric + seq_scan::numeric), 0)) * 100, 2) AS \"IDX_scan_%\", trunc((seq_scan::numeric / NULLIF((idx_scan::numeric + seq_scan::numeric), 0)) * 100, 2) AS \"FTS_scan_%\", CASE WHEN seq_scan > idx_scan THEN 'FTS' ELSE 'IDX' END AS access_profile, a.n_live_tup, a.n_dead_tup, trunc((n_dead_tup::numeric / NULLIF(n_live_tup::numeric, 0)) * 100, 2) AS \"dead_tup_%\", a.n_tup_ins, a.n_tup_upd, a.n_tup_del, trunc((n_tup_ins::numeric / NULLIF((n_tup_ins::numeric + n_tup_upd::numeric + n_tup_del::numeric), 0)) * 100, 2) AS \"tup_ins_%\", trunc((n_tup_upd::numeric / NULLIF((n_tup_ins::numeric + n_tup_upd::numeric + n_tup_del::numeric), 0)) * 100, 2) AS \"tup_upd_%\", trunc((n_tup_del::numeric / NULLIF((n_tup_ins::numeric + n_tup_upd::numeric + n_tup_del::numeric), 0)) * 100, 2) AS \"tup_del_%\" FROM pg_stat_all_tables a, table_size_info b WHERE a.relid = b.relid AND schema_name NOT IN ('pg_catalog') ORDER BY b.relation_size DESC;",
      "args": [],
      "context": "Identify tables with excessive full table scans."
    },
    {
      "name": "Tables with More Full Table Scans than Index Scans",
      "description": "Lists tables with more full table scans than index scans.",
      "query": "WITH table_size_info AS (SELECT schemaname AS schema_name, relname AS \"Table\", pg_relation_size(relid) AS relation_size, relid, pg_size_pretty(pg_relation_size(relid)) AS \"table_size\", pg_size_pretty(pg_total_relation_size(relid)) AS \"TABLE size + indexes\", pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS \"indexes size\" FROM pg_catalog.pg_statio_all_tables ORDER BY 1, 3 DESC) SELECT b.schema_name, a.relname AS \"Table_Name\", b.table_size AS \"Table_Size\", a.seq_scan AS total_fts_scan, a.seq_tup_read AS total_fts_num_rows_reads, a.seq_tup_read / NULLIF(a.seq_scan, 0) AS fts_rows_per_read, a.idx_scan AS total_idx_scan, a.idx_tup_fetch AS total_Idx_num_rows_read, a.idx_tup_fetch / NULLIF(a.idx_scan, 0) AS idx_rows_per_read, trunc((idx_scan::numeric / NULLIF((idx_scan::numeric + seq_scan::numeric), 0)) * 100, 2) AS \"IDX_scan_%\", trunc((seq_scan::numeric / NULLIF((idx_scan::numeric + seq_scan::numeric), 0)) * 100, 2) AS \"FTS_scan_%\", CASE WHEN seq_scan > idx_scan THEN 'FTS' ELSE 'IDX' END AS access_profile, a.n_live_tup, a.n_dead_tup, trunc((n_dead_tup::numeric / NULLIF(n_live_tup::numeric, 0)) * 100, 2) AS \"dead_tup_%\", a.n_tup_ins, a.n_tup_upd, a.n_tup_del, trunc((n_tup_ins::numeric / NULLIF((n_tup_ins::numeric + n_tup_upd::numeric + n_tup_del::numeric), 0)) * 100, 2) AS \"tup_ins_%\", trunc((n_tup_upd::numeric / NULLIF((n_tup_ins::numeric + n_tup_upd::numeric + n_tup_del::numeric), 0)) * 100, 2) AS \"tup_upd_%\", trunc((n_tup_del::numeric / NULLIF((n_tup_ins::numeric + n_tup_upd::numeric + n_tup_del::numeric), 0)) * 100, 2) AS \"tup_del_%\" FROM pg_stat_all_tables a, table_size_info b WHERE a.relid = b.relid AND schema_name NOT IN ('pg_catalog', 'pg_toast') AND seq_scan > idx_scan AND b.relation_size > 10485760 ORDER BY b.relation_size DESC;",
      "args": [],
      "context": "Identify tables with inefficient access patterns."
    },
    {
      "name": "Top 50 Tables by Total Physical Reads",
      "description": "Lists the top 50 tables with the highest total physical reads.",
      "query": "SELECT s2.*, coalesce(trunc((s2.total_physical_reads::numeric / NULLIF((s2.total_physical_reads::numeric + s2.total_logical_reads::numeric), 0)) * 100, 2), 0) AS physical_reads_percent, coalesce(trunc((s2.total_logical_reads::numeric / NULLIF((s2.total_physical_reads::numeric + s2.total_logical_reads::numeric), 0)) * 100, 2), 0) AS logical_reads_percent FROM (SELECT s.*, s.table_disk_blocks_read + s.indexes_disk_blocks_read + s.TOAST_table_disk_blocks_read + s.TOAST_indexes_disk_blocks_read AS total_physical_reads, s.table_buffer_hits + s.indexes_buffer_hits + s.TOAST_table_buffer_hits + s.TOAST_indexes_buffer_hits AS total_logical_reads FROM (SELECT schemaname AS schema_name, relname AS table_name, coalesce(heap_blks_read, 0) AS table_disk_blocks_read, coalesce(heap_blks_hit, 0) AS table_buffer_hits, coalesce(idx_blks_read, 0) AS indexes_disk_blocks_read, coalesce(idx_blks_hit, 0) AS indexes_buffer_hits, coalesce(toast_blks_read, 0) AS TOAST_table_disk_blocks_read, coalesce(toast_blks_hit, 0) AS TOAST_table_buffer_hits, coalesce(tidx_blks_read, 0) AS TOAST_indexes_disk_blocks_read, coalesce(tidx_blks_hit, 0) AS TOAST_indexes_buffer_hits FROM pg_statio_all_tables WHERE schemaname NOT IN ('pg_toast', 'pg_catalog', 'information_schema')) AS s) AS s2 ORDER BY s2.total_physical_reads DESC LIMIT 50;",
      "args": [],
      "context": "Identify tables with high physical I/O."
    },
    {
      "name": "Top Tables by Total Physical Read Percent",
      "description": "Lists tables with the highest percentage of physical reads.",
      "query": "SELECT s2.*, coalesce(trunc((s2.total_physical_reads::numeric / NULLIF((s2.total_physical_reads::numeric + s2.total_logical_reads::numeric), 0)) * 100, 2), 0) AS physical_reads_percent, coalesce(trunc((s2.total_logical_reads::numeric / NULLIF((s2.total_physical_reads::numeric + s2.total_logical_reads::numeric), 0)) * 100, 2), 0) AS logical_reads_percent FROM (SELECT s.*, s.table_disk_blocks_read + s.indexes_disk_blocks_read + s.TOAST_table_disk_blocks_read + s.TOAST_indexes_disk_blocks_read AS total_physical_reads, s.table_buffer_hits + s.indexes_buffer_hits + s.TOAST_table_buffer_hits + s.TOAST_indexes_buffer_hits AS total_logical_reads FROM (SELECT schemaname AS schema_name, relname AS table_name, coalesce(heap_blks_read, 0) AS table_disk_blocks_read, coalesce(heap_blks_hit, 0) AS table_buffer_hits, coalesce(idx_blks_read, 0) AS indexes_disk_blocks_read, coalesce(idx_blks_hit, 0) AS indexes_buffer_hits, coalesce(toast_blks_read, 0) AS TOAST_table_disk_blocks_read, coalesce(toast_blks_hit, 0) AS TOAST_table_buffer_hits, coalesce(tidx_blks_read, 0) AS TOAST_indexes_disk_blocks_read, coalesce(tidx_blks_hit, 0) AS TOAST_indexes_buffer_hits FROM pg_statio_all_tables WHERE schemaname NOT IN ('pg_toast', 'pg_catalog', 'information_schema')) AS s) AS s2 ORDER BY physical_reads_percent DESC LIMIT 50;",
      "args": [],
      "context": "Identify tables with inefficient caching."
    },
    {
      "name": "Unused Indexes",
      "description": "Lists indexes that have never been used.",
      "query": "SELECT ai.schemaname, ai.relname AS tablename, ai.indexrelid AS index_oid, ai.indexrelname AS indexname, i.indisunique, ai.idx_scan, pg_relation_size(ai.indexrelid) AS index_size, pg_size_pretty(pg_relation_size(ai.indexrelid)) AS pretty_index_size FROM pg_catalog.pg_stat_all_indexes ai, pg_index i WHERE ai.indexrelid = i.indexrelid AND ai.idx_scan = 0 AND ai.schemaname NOT IN ('pg_catalog') ORDER BY index_size DESC;",
      "args": [],
      "context": "Identify unused indexes for potential removal."
    },
    {
      "name": "Index Access Profile",
      "description": "Analyzes index usage patterns.",
      "query": "WITH index_size_info AS (SELECT schemaname, relname AS \"Table\", indexrelname AS indexname, indexrelid, pg_relation_size(indexrelid) AS index_size_byte, pg_size_pretty(pg_relation_size(indexrelid)) AS index_size FROM pg_catalog.pg_statio_all_indexes ORDER BY 1, 4 DESC) SELECT a.schemaname, a.relname AS \"Table_Name\", a.indexrelname AS indexname, b.index_size, a.idx_scan, a.idx_tup_read, a.idx_tup_fetch FROM pg_stat_all_indexes a, index_size_info b WHERE a.idx_scan > 0 AND a.indexrelid = b.indexrelid AND a.schemaname NOT IN ('pg_catalog') ORDER BY b.index_size_byte DESC, a.idx_scan ASC;",
      "args": [],
      "context": "Review index usage and performance."
    },
    {
      "name": "Top Indexes by Total Physical Reads",
      "description": "Lists indexes with the highest total physical reads.",
      "query": "SELECT schemaname AS schema_name, relname AS table_name, indexrelname AS index_name, coalesce(idx_blks_read, 0) AS indexe_disk_blocks_read, coalesce(idx_blks_hit, 0) AS indexe_buffer_hits, coalesce(trunc((coalesce(idx_blks_read, 0) / NULLIF(coalesce(idx_blks_read, 0) + coalesce(idx_blks_hit, 0), 0)) * 100, 2), 0) AS physical_reads_percent, coalesce(trunc((coalesce(idx_blks_hit, 0) / NULLIF(coalesce(idx_blks_read, 0) + coalesce(idx_blks_hit, 0), 0)) * 100, 2), 0) AS logical_reads_percent FROM pg_statio_all_indexes WHERE schemaname NOT IN ('pg_toast', 'pg_catalog', 'information_schema') ORDER BY indexe_disk_blocks_read DESC LIMIT 50;",
      "args": [],
      "context": "Identify indexes with high physical I/O."
    },
    {
      "name": "Table and Index Bloat (Fragmentation)",
      "description": "Estimates table and index bloat (fragmentation).",
      "query": "SELECT current_database(), schemaname, tablename, ROUND((CASE WHEN otta = 0 THEN 0.0 ELSE sml.relpages::FLOAT / otta END)::NUMERIC, 1) AS \"table_bloat_ratio\", CASE WHEN relpages < otta THEN 0 ELSE bs * (sml.relpages - otta)::BIGINT END AS wastedbytes, pg_size_pretty(CASE WHEN relpages < otta THEN 0 ELSE bs * (sml.relpages - otta)::BIGINT END) AS table_wasted_size, iname AS Index_nam, ROUND((CASE WHEN iotta = 0 OR ipages = 0 THEN 0.0 ELSE ipages::FLOAT / iotta END)::NUMERIC, 1) AS \"Index_bloat_ratio\", CASE WHEN ipages < iotta THEN 0 ELSE bs * (ipages - iotta) END AS wastedibytes, pg_size_pretty(CASE WHEN ipages < iotta THEN 0 ELSE bs * (ipages - iotta)::BIGINT END) AS Index_wasted_size FROM (SELECT schemaname, tablename, cc.reltuples, cc.relpages, bs, CEIL((cc.reltuples * ((datahdr + ma - (CASE WHEN datahdr % ma = 0 THEN ma ELSE datahdr % ma END)) + nullhdr2 + 4)) / (bs - 20::FLOAT)) AS otta, COALESCE(c2.relname, '?') AS iname, COALESCE(c2.reltuples, 0) AS ituples, COALESCE(c2.relpages, 0) AS ipages, COALESCE(CEIL((c2.reltuples * (datahdr - 12)) / (bs - 20::FLOAT)), 0) AS iotta FROM (SELECT ma, bs, schemaname, tablename, (datawidth + (hdr + ma - (CASE WHEN hdr % ma = 0 THEN ma ELSE hdr % ma END)))::NUMERIC AS datahdr, (maxfracsum * (nullhdr + ma - (CASE WHEN nullhdr % ma = 0 THEN ma ELSE nullhdr % ma END))) AS nullhdr2 FROM (SELECT schemaname, tablename, hdr, ma, bs, SUM((1 - null_frac) * avg_width) AS datawidth, MAX(null_frac) AS maxfracsum, hdr + (SELECT 1 + COUNT(*) / 8 FROM pg_stats s2 WHERE null_frac <> 0 AND s2.tablename = s.tablename AND s2.schemaname = s.schemaname) AS nullhdr FROM pg_stats s WHERE schemaname NOT IN ('pg_catalog', 'information_schema') GROUP BY 1, 2, 3, 4, 5) AS foo) AS rs JOIN pg_class cc ON cc.relname = rs.tablename JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname LEFT JOIN pg_index i ON indrelid = cc.oid LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid) AS sml ORDER BY wastedbytes DESC;",
      "args": [],
      "context": "Identify bloated tables and indexes for vacuuming or reindexing."
    },
    {
        "name": "Bloat by Ratio",
        "description": "Lists tables and indexes with the highest bloat ratios.",
        "query": "SELECT current_database(), schemaname, tablename, ROUND((CASE WHEN otta = 0 THEN 0.0 ELSE sml.relpages::FLOAT / otta END)::NUMERIC, 1) AS \"table_bloat_ratio\", CASE WHEN relpages < otta THEN 0 ELSE bs * (sml.relpages - otta)::BIGINT END AS wastedbytes, pg_size_pretty(CASE WHEN relpages < otta THEN 0 ELSE bs * (sml.relpages - otta)::BIGINT END) AS table_wasted_size, iname AS Index_nam, ROUND((CASE WHEN iotta = 0 OR ipages = 0 THEN 0.0 ELSE ipages::FLOAT / iotta END)::NUMERIC, 1) AS \"Index_bloat_ratio\", CASE WHEN ipages < iotta THEN 0 ELSE bs * (ipages - iotta) END AS wastedibytes, pg_size_pretty(CASE WHEN ipages < iotta THEN 0 ELSE bs * (ipages - iotta)::BIGINT END) AS Index_wasted_size FROM (SELECT schemaname, tablename, cc.reltuples, cc.relpages, bs, CEIL((cc.reltuples * ((datahdr + ma - (CASE WHEN datahdr % ma = 0 THEN ma ELSE datahdr % ma END)) + nullhdr2 + 4)) / (bs - 20::FLOAT)) AS otta, COALESCE(c2.relname, '?') AS iname, COALESCE(c2.reltuples, 0) AS ituples, COALESCE(c2.relpages, 0) AS ipages, COALESCE(CEIL((c2.reltuples * (datahdr - 12)) / (bs - 20::FLOAT)), 0) AS iotta FROM (SELECT ma, bs, schemaname, tablename, (datawidth + (hdr + ma - (CASE WHEN hdr % ma = 0 THEN ma ELSE hdr % ma END)))::NUMERIC AS datahdr, (maxfracsum * (nullhdr + ma - (CASE WHEN nullhdr % ma = 0 THEN ma ELSE nullhdr % ma END))) AS nullhdr2 FROM (SELECT schemaname, tablename, hdr, ma, bs, SUM((1 - null_frac) * avg_width) AS datawidth, MAX(null_frac) AS maxfracsum, hdr + (SELECT 1 + COUNT(*) / 8 FROM pg_stats s2 WHERE null_frac <> 0 AND s2.tablename = s.tablename AND s2.schemaname = s.schemaname) AS nullhdr FROM pg_stats s WHERE schemaname NOT IN ('pg_catalog', 'information_schema') GROUP BY 1, 2, 3, 4, 5) AS foo) AS rs JOIN pg_class cc ON cc.relname = rs.tablename JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname LEFT JOIN pg_index i ON indrelid = cc.oid LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid) AS sml ORDER BY 4 DESC;",
        "args": [],
        "context": "Identify bloated tables and indexes by ratio."
      },
      {
        "name": "TOAST Table Mapping",
        "description": "Maps TOAST tables to their parent tables and shows their sizes.",
        "query": "SELECT t.relname AS table_name, r.relname AS toast_name, r.oid AS toast_oid, pg_relation_size(t.reltoastrelid) AS toast_size_bytes, pg_size_pretty(pg_relation_size(t.reltoastrelid)) AS toast_size FROM pg_class r INNER JOIN pg_class t ON r.oid = t.reltoastrelid ORDER BY toast_size_bytes DESC;",
        "args": [],
        "context": "Review TOAST table usage and sizes."
      },
      {
        "name": "Replication Lag",
        "description": "Shows replication lag in MB/GB for replication slots.",
        "query": "SELECT slot_name, slot_type, database, active, coalesce(round(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) / 1024 / 1024, 2), 0) AS Lag_MB_behind, coalesce(round(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) / 1024 / 1024 / 1024, 2), 0) AS Lag_GB_behind FROM pg_replication_slots ORDER BY Lag_MB_behind DESC;",
        "args": [],
        "context": "Monitor replication delay for standby servers."
      },
      {
        "name": "Replication Parameters",
        "description": "Lists key replication-related settings.",
        "query": "SELECT name AS parameter_name, setting, unit, short_desc FROM pg_catalog.pg_settings WHERE name IN ('wal_level', 'max_wal_senders', 'max_replication_slots', 'max_worker_processes', 'max_logical_replication_workers', 'wal_receiver_timeout', 'max_sync_workers_per_subscription', 'wal_receiver_status_interval', 'wal_retrieve_retry_interval', 'logical_decoding_work_mem', 'max_slot_wal_keep_size');",
        "args": [],
        "context": "Review replication configuration parameters."
      },
      {
        "name": "Connection Utilization",
        "description": "Shows current connection usage statistics.",
        "query": "WITH settings AS (SELECT setting::float AS max_connections FROM pg_settings WHERE name = 'max_connections'), connections AS (SELECT sum(numbackends)::float total_connections FROM pg_stat_database) SELECT settings.max_connections AS Max_connections, total_connections AS Total_connections, ROUND((100 * (connections.total_connections / settings.max_connections))::numeric, 2) AS Connections_utilization_percent FROM settings, connections;",
        "args": [],
        "context": "Monitor connection pool usage and capacity."
      },
      {
        "name": "Active Session Monitor",
        "description": "Lists active sessions with transaction and query durations.",
        "query": "SELECT usename, pid, now() - pg_stat_activity.xact_start AS xact_duration, now() - pg_stat_activity.query_start AS query_duration, substr(query, 1, 50) AS query, query_id, state, wait_event FROM pg_stat_activity WHERE (xact_duration IS NOT NULL OR query_duration IS NOT NULL) AND state != 'idle' AND query NOT LIKE '%active_session_monitor%' ORDER BY xact_duration DESC, query_duration DESC;",
        "args": [],
        "context": "Monitor long-running transactions and queries."
      },
      {
        "name": "Invalid Indexes",
        "description": "Lists invalid indexes in the database.",
        "query": "WITH table_info AS (SELECT pg_index.indrelid, pg_class.oid, pg_class.relname AS table_name FROM pg_class, pg_index WHERE pg_index.indrelid = pg_class.oid) SELECT DISTINCT pg_index.indexrelid AS INDX_ID, pg_class.relname AS index_name, table_info.table_name, pg_namespace.nspname AS schema_name, pg_class.relowner AS owner_id, pg_index.indisvalid AS indx_is_valid FROM pg_class, pg_index, pg_namespace, table_info WHERE pg_index.indisvalid = false AND pg_index.indexrelid = pg_class.oid AND pg_class.relnamespace = pg_namespace.oid AND pg_index.indrelid = table_info.oid;",
        "args": [],
        "context": "Identify indexes that are marked as invalid."
      },
      {
        "name": "Access Privileges",
        "description": "Lists access privileges for tables, views, and sequences.",
        "query": "SELECT n.nspname AS \"Schema\", c.relname AS \"Name\", CASE c.relkind WHEN 'r' THEN 'table' WHEN 'v' THEN 'view' WHEN 'm' THEN 'materialized view' WHEN 'S' THEN 'sequence' WHEN 'f' THEN 'foreign table' END AS \"Type\", pg_catalog.array_to_string(c.relacl, E'\n') AS \"Access privileges\", pg_catalog.array_to_string(ARRAY(SELECT attname || E':\n  ' || pg_catalog.array_to_string(attacl, E'\n  ') FROM pg_catalog.pg_attribute a WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL), E'\n') AS \"Column access privileges\" FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace WHERE c.relkind IN ('r', 'v', 'm', 'S', 'f') AND n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid) ORDER BY 1, 3, 2;",
        "args": [],
        "context": "Review object-level and column-level permissions."
      },
      {
        "name": "Temporary Tables",
        "description": "Lists temporary table statistics, including size and file count.",
        "query": "SELECT datname AS database_name, temp_bytes / 1024 / 1024 AS temp_size_MB, temp_bytes / 1024 / 1024 / 1024 AS temp_size_GB, temp_files FROM pg_stat_database WHERE temp_bytes + temp_files > 0 AND datname IS NOT NULL ORDER BY 2 DESC;",
        "args": [],
        "context": "Monitor temporary table usage and resource consumption."
      },
      {
        "name": "Partitioned Tables",
        "description": "Lists partitioned tables and their partition counts.",
        "query": "SELECT parent.oid AS parent_table_oid, parent.relname AS parent_table_name, count(child.oid) AS partition_count FROM pg_inherits JOIN pg_class parent ON pg_inherits.inhparent = parent.oid JOIN pg_class child ON pg_inherits.inhrelid = child.oid GROUP BY 1, 2 ORDER BY 3 DESC;",
        "args": [],
        "context": "Review partitioned table structures."
      },
      {
        "name": "Foreign Keys Without Indexes",
        "description": "Lists foreign keys that lack supporting indexes.",
        "query": "SELECT c.conrelid::regclass AS \"table\", string_agg(a.attname, ',' ORDER BY x.n) AS columns, pg_catalog.pg_size_pretty(pg_catalog.pg_relation_size(c.conrelid)) AS size, c.conname AS constraint, c.confrelid::regclass AS referenced_table FROM pg_catalog.pg_constraint c CROSS JOIN LATERAL unnest(c.conkey) WITH ORDINALITY AS x(attnum, n) JOIN pg_catalog.pg_attribute a ON a.attnum = x.attnum AND a.attrelid = c.conrelid WHERE NOT EXISTS (SELECT 1 FROM pg_catalog.pg_index i WHERE i.indrelid = c.conrelid AND (i.indkey::smallint[])[0:cardinality(c.conkey) - 1] OPERATOR(pg_catalog.@>) c.conkey) AND c.contype = 'f' GROUP BY c.conrelid, c.conname, c.confrelid ORDER BY pg_catalog.pg_relation_size(c.conrelid) DESC;",
        "args": [],
        "context": "Identify foreign keys causing performance issues due to missing indexes."
      },
      {
        "name": "Sequences with Less Than 10% Remaining",
        "description": "Lists sequences nearing their maximum value.",
        "query": "SELECT * FROM (SELECT *, (sec.max_value - coalesce(sec.last_value, 0)) AS remain_values, round((((sec.max_value - coalesce(sec.last_value, 0)::float) / sec.max_value::float) * 100)::int, 2) AS remain_values_pct FROM pg_sequences sec) t WHERE remain_values_pct < 10;",
        "args": [],
        "context": "Monitor sequences at risk of wraparound."
      },
      {
        "name": "Blocking Sessions",
        "description": "Counts sessions blocked by other transactions.",
        "query": "SELECT count(*) FROM pg_stat_activity WHERE cardinality(pg_blocking_pids(pid)) > 0;",
        "args": [],
        "context": "Troubleshoot locking and blocking issues."
      }
    ]